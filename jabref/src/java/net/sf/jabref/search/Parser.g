header {
package net.sf.jabref.search;
}

class SearchExpressionParser extends Parser;

options {
	importVocab = SearchExpressionLexer; // use vocab generated by lexer
	exportVocab = SearchExpressionParser;
	defaultErrorHandler = false;
	buildAST = true;
	k = 3;
}

tokens {
	RegularExpression;
	And;
	Or;
	Not;
	ExpressionSearch;
}

// ---------- Java Source Code ----------

{
	public boolean caseSensitive = false;
}

// ---------- Text and Regular Expressions ----------

quotedRegularExpression[boolean caseSensitive]:
		var_s:STRING
			{
				## = astFactory.make((new ASTArray(2)).add(new RegExNode(RegularExpression,var_s.getText(),caseSensitive)).add(##));
			}
		;

simpleRegularExpression[boolean caseSensitive]:
		var_s:FIELDTYPE
			{
				## = astFactory.make((new ASTArray(2)).add(new RegExNode(RegularExpression,var_s.getText(),caseSensitive)).add(##));
			}
		;

// ---------- Condition and Expressions ----------

searchExpression:
	condition EOF;

condition:
		(expression LITERAL_and condition) => expression LITERAL_and! condition { ## = #( [And], ##); }
		|
		(expression LITERAL_or condition) => expression LITERAL_or! condition { ## = #( [Or], ##); }
		|
		expression // negation is done in expression
		;

expression:
		expressionSearch
		|
		LPAREN! condition RPAREN!
		|
		LITERAL_not! expressionSearch { ## = #( [Not], ## ); }         // NOT single expression
		|
		LITERAL_not! LPAREN! condition RPAREN! { ## = #( [Not], ## ); } // NOT ( ... )
		;

expressionSearch:
		quotedRegularExpression[false] compareType quotedRegularExpression[caseSensitive]
			{ ## = #( [ExpressionSearch], ## ); }
		|
		simpleRegularExpression[false] compareType quotedRegularExpression[caseSensitive]
			{ ## = #( [ExpressionSearch], ## ); }
		|
		simpleRegularExpression[false] compareType simpleRegularExpression[caseSensitive]
			{ ## = #( [ExpressionSearch], ## ); }
		;

compareType:
		LITERAL_contains | LITERAL_matches | EQUAL | EEQUAL | NEQUAL
		;

